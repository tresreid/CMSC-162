// dict.c
// Hash-based dictionary.

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "dict.h"
#include "hash.h"

void dict_initialize(dict_type *d) {
    dict_cell **dp = d->contents;
    for (int i = 0; i < DICT_SIZE; ++i) {
        dp[i] = NULL;
    }
}

void dict_increment(dict_type *dp, char *word){
    dict_cell **bp = &dp->contents[hash(word) & DICT_MASK];
    
    while(*bp != NULL && strcmp((*bp)->entry.word,word)) {
        bp = &(*bp)->next;
    }
    
    if (*bp == NULL) {
        // allocate a new cell...
    
        (*bp) = (dict_cell *) malloc (sizeof(dict_cell));
        assert(*bp != NULL);
        
        (*bp)->next = NULL;
        (*bp)->entry.word = strdup(word);
        (*bp)->entry.count = 0;
    }
    
    ++(*bp)->entry.count;
    
    return;
}

static int de_compare(const void *a, const void *b) {
	dict_entry_type *ap = * (dict_entry_type **)a;
	dict_entry_type *bp = * (dict_entry_type **)b;
	int diff = bp->count - ap->count;
	if (diff != 0) {
	    return diff;
	}
	return strcmp(ap->word,bp->word);
}


dict_entry_type **dict_get_entries(dict_type *d) {
	// count the entries...
	
	int count = 0;
	
	for (int i = 0; i < DICT_SIZE; ++i) {
	    // traverse bucket i
	    
	    dict_cell *dcp = d->contents[i];
	    
	    while (dcp != NULL) {
	        ++count;
	        dcp = dcp->next;
	    }
	}
	
	
	dict_entry_type **result = (dict_entry_type **) calloc(count+1,sizeof(dict_entry_type *));
	assert(result != NULL);
    
	int index = 0;
	
	// load the entries
	
	for (int i = 0; i < DICT_SIZE; ++i) {
	    dict_cell *dcp = d->contents[i];
	    
	    while (dcp != NULL) {
	        result[index++] = &dcp->entry;
	        dcp = dcp->next;
	    }
	}
	
	assert(index == count);
	result[index] = NULL;
	
	qsort((void*) result, count, sizeof(dict_entry_type *),de_compare);
	
	return result;
}

